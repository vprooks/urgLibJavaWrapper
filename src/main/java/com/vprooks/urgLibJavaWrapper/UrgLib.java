package com.vprooks.urgLibJavaWrapper;

import com.sun.jna.*;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.NativeLongByReference;

import java.nio.ByteBuffer;
import java.nio.ShortBuffer;

/**
 * JNA Wrapper for library <b>urg_sensor</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface UrgLib extends Library {
    public static final String JNA_LIBRARY_NAME = "urg_c";
    public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(UrgLib.JNA_LIBRARY_NAME);
    public static final UrgLib INSTANCE = (UrgLib) Native.loadLibrary(UrgLib.JNA_LIBRARY_NAME, UrgLib.class);
    public static final int RING_BUFFER_SIZE_SHIFT = 7;
    public static final int RING_BUFFER_SIZE = 1 << (int) UrgLib.RING_BUFFER_SIZE_SHIFT;
    public static final int ERROR_MESSAGE_SIZE = 256;
    public static final int RB_BITSHIFT = 8;
    public static final int RB_SIZE = 1 << (int) UrgLib.RB_BITSHIFT;
    public static final int BUFSIZE = (int) UrgLib.RB_SIZE - 1;
    /**
     * !<  Return value in case of timeout
     */
    public static final int URG_CONNECTION_TIMEOUT = -1;

    /**
     * <i>native declaration : urg_connection.h</i><br>
     * enum values
     */
    public static interface urg_connection_type_t {
        /**
         * <i>native declaration : urg_connection.h:22</i>
         */
        public static final int URG_SERIAL = 0;
        /**
         * <i>native declaration : urg_connection.h:23</i>
         */
        public static final int URG_ETHERNET = 1;
    }

    /**
     * <i>native declaration : urg_sensor.h</i><br>
     * enum values
     */
    public static interface urg_measurement_type_t {
        /**
         * <i>native declaration : urg_sensor.h:16</i>
         */
        public static final int URG_DISTANCE = 0;
        /**
         * <i>native declaration : urg_sensor.h:17</i>
         */
        public static final int URG_DISTANCE_INTENSITY = 1;
        /**
         * <i>native declaration : urg_sensor.h:18</i>
         */
        public static final int URG_MULTIECHO = 2;
        /**
         * <i>native declaration : urg_sensor.h:19</i>
         */
        public static final int URG_MULTIECHO_INTENSITY = 3;
        /**
         * <i>native declaration : urg_sensor.h:20</i>
         */
        public static final int URG_STOP = 4;
        /**
         * <i>native declaration : urg_sensor.h:21</i>
         */
        public static final int URG_UNKNOWN = 5;
    }

    ;

    /**
     * <i>native declaration : urg_sensor.h</i><br>
     * enum values
     */
    public static interface urg_range_data_byte_t {
        /**
         * <i>native declaration : urg_sensor.h:28</i>
         */
        public static final int URG_COMMUNICATION_3_BYTE = 0;
        /**
         * <i>native declaration : urg_sensor.h:29</i>
         */
        public static final int URG_COMMUNICATION_2_BYTE = 1;
    }

    /**
     * !<  Continuous data scanning
     */
    public static final int URG_SCAN_INFINITY = 0;
    /**
     * !<  Maximum number of echoes
     */
    public static final int URG_MAX_ECHO = 3;

    /**
     * <i>native declaration : urg_sensor.h</i>
     */
    public interface urg_error_handler extends Callback {
        int apply(Pointer status, Pointer urg);
    }

    /**
     * \brief Initialization
     * <br>
     * \param[in] ring Pointer to the ring buffer data structure
     * <br>
     * \param[in] buffer Actual buffer to use
     * <br>
     * \param[in] shift_length Buffer size as multiple of 2<br>
     * Original signature : <code>void ring_initialize(ring_buffer_t*, char*, const int)</code><br>
     * <i>native declaration : urg_ring_buffer.h:30</i>
     */
    void ring_initialize(ring_buffer_t ring, ByteBuffer buffer, int shift_length);

    /**
     * \brief Clears the ring  buffer
     * <br>
     * \param[in] ring Pointer to the ring buffer data structure<br>
     * Original signature : <code>void ring_clear(ring_buffer_t*)</code><br>
     * <i>native declaration : urg_ring_buffer.h:39</i>
     */
    void ring_clear(ring_buffer_t ring);

    /**
     * \brief Returns the number of elements on the buffer
     * <br>
     * \param[in] ring Pointer to the ring buffer data structure<br>
     * Original signature : <code>int ring_size(const ring_buffer_t*)</code><br>
     * <i>native declaration : urg_ring_buffer.h:47</i>
     */
    int ring_size(ring_buffer_t ring);

    /**
     * \brief Returns the maximum number of elements of the ring buffer
     * <br>
     * \param[in] ring Pointer to the ring buffer data structure<br>
     * Original signature : <code>int ring_capacity(const ring_buffer_t*)</code><br>
     * <i>native declaration : urg_ring_buffer.h:55</i>
     */
    int ring_capacity(ring_buffer_t ring);

    /**
     * \brief Stores data on the ring buffer
     * <br>
     * \param[in] ring Pointer to the ring buffer data structure
     * <br>
     * \param[in] data Data to store
     * <br>
     * \param[in] size Number of elements to store
     * <br>
     * \return The number of elements written to the ring buffer<br>
     * Original signature : <code>int ring_write(ring_buffer_t*, const char*, int)</code><br>
     * <i>native declaration : urg_ring_buffer.h:67</i>
     */
    int ring_write(ring_buffer_t ring, String data, int size);

    /**
     * \brief Extracts data from the ring buffer
     * <br>
     * \param[in] ring Pointer to the ring buffer data structure
     * <br>
     * \param[out] buffer Buffer to hold the extracted data
     * <br>
     * \param[in] size Maximum size of the buffer
     * <br>
     * \return The number of elements read from the ring buffer<br>
     * Original signature : <code>int ring_read(ring_buffer_t*, char*, int)</code><br>
     * <i>native declaration : urg_ring_buffer.h:79</i>
     */
    int ring_read(ring_buffer_t ring, ByteBuffer buffer, int size);

    /**
     * !  Opens the connection<br>
     * Original signature : <code>int serial_open(urg_serial_t*, const char*, long)</code><br>
     * <i>native declaration : urg_serial.h:37</i>
     */
    int serial_open(urg_serial_t serial, String device, NativeLong baudrate);

    /**
     * !  Closes the connection<br>
     * Original signature : <code>void serial_close(urg_serial_t*)</code><br>
     * <i>native declaration : urg_serial.h:41</i>
     */
    void serial_close(urg_serial_t serial);

    /**
     * !  Configures the baudrate<br>
     * Original signature : <code>int serial_set_baudrate(urg_serial_t*, long)</code><br>
     * <i>native declaration : urg_serial.h:45</i>
     */
    int serial_set_baudrate(urg_serial_t serial, NativeLong baudrate);

    /**
     * !  Sends data over serial connection<br>
     * Original signature : <code>int serial_write(urg_serial_t*, const char*, int)</code><br>
     * <i>native declaration : urg_serial.h:49</i>
     */
    int serial_write(urg_serial_t serial, String data, int size);

    /**
     * !  Gets data from serial connection<br>
     * Original signature : <code>int serial_read(urg_serial_t*, char*, int, int)</code><br>
     * <i>native declaration : urg_serial.h:53</i>
     */
    int serial_read(urg_serial_t serial, ByteBuffer data, int max_size, int timeout);

    /**
     * !  Gets data from serial connection until end-of-line<br>
     * Original signature : <code>int serial_readline(urg_serial_t*, char*, int, int)</code><br>
     * <i>native declaration : urg_serial.h:58</i>
     */
    int serial_readline(urg_serial_t serial, ByteBuffer data, int max_size, int timeout);

    /**
     * !  Stores the serial error message<br>
     * Original signature : <code>int serial_error(urg_serial_t*, char*, int)</code><br>
     * <i>native declaration : urg_serial.h:63</i>
     */
    int serial_error(urg_serial_t serial, ByteBuffer error_message, int max_size);

    /**
     * \brief constructor of tcp client module
     * <br>
     * \param[in,out] cli tcp client type variable which must be allocated by a caller.
     * <br>
     * \param[in] server_ip_str IP address expressed in string, i.e. "192.168.0.1"
     * <br>
     * \param[in] port_num port number expressed in integer, i.e. port_num = 10200
     * <br>
     * \retval 0 succeeded.
     * <br>
     * \retval -1 error<br>
     * Original signature : <code>int tcpclient_open(urg_tcpclient_t*, const char*, int)</code><br>
     * <i>native declaration : urg_tcpclient.h:47</i>
     */
    int tcpclient_open(urg_tcpclient_t cli, String server_ip_str, int port_num);

    /**
     * \brief destructor of tcp client module
     * <br>
     * \param[in,out] cli : tcp client type variable which must be deallocated by a caller after closing.<br>
     * Original signature : <code>void tcpclient_close(urg_tcpclient_t*)</code><br>
     * <i>native declaration : urg_tcpclient.h:56</i>
     */
    void tcpclient_close(urg_tcpclient_t cli);

    /**
     * \brief read from socket.
     * <br>
     * \param[in,out] cli : tcp client type variable which must be deallocated by a caller after closing.
     * <br>
     * \param[out] userbuf : buffer to store read data which must be allocated by a caller.
     * <br>
     * \param[in] req_size: data size requested to read in byte.
     * <br>
     * \param[in] timeout : time out specification which unit is microsecond.
     * <br>
     * \return the number of data read, -1 when error.<br>
     * Original signature : <code>int tcpclient_read(urg_tcpclient_t*, char*, int, int)</code><br>
     * <i>native declaration : urg_tcpclient.h:69</i>
     */
    int tcpclient_read(urg_tcpclient_t cli, ByteBuffer userbuf, int req_size, int timeout);

    /**
     * \brief write to socket.
     * <br>
     * \param[in,out] cli : tcp client type variable which must be deallocated by a caller after closing.
     * <br>
     * \param[in] userbuf : data to write.
     * <br>
     * \param[in] req_size: data size requested to write in byte.
     * <br>
     * \return returns the number of data wrote, -1 when error.<br>
     * Original signature : <code>int tcpclient_write(urg_tcpclient_t*, const char*, int)</code><br>
     * <i>native declaration : urg_tcpclient.h:82</i>
     */
    int tcpclient_write(urg_tcpclient_t cli, String userbuf, int req_size);

    /**
     * ! \attention not implemented yet.<br>
     * Original signature : <code>int tcpclient_error(urg_tcpclient_t*, char*, int)</code><br>
     * <i>native declaration : urg_tcpclient.h:87</i>
     */
    int tcpclient_error(urg_tcpclient_t cli, ByteBuffer error_message, int max_size);

    /**
     * \brief read one line from socket.
     * <br>
     * \param[in,out] cli : tcp client type variable which must be deallocated by a caller after closing.
     * <br>
     * \param[out] userbuf : buffer to store read data which must be allocated by a caller.
     * <br>
     * \param[in] buf_size: data size requested to read in byte.
     * <br>
     * \param[in] timeout : time out specification which unit is microsecond.
     * <br>
     * \return the number of data read, -1 when error.<br>
     * Original signature : <code>int tcpclient_readline(urg_tcpclient_t*, char*, int, int)</code><br>
     * <i>native declaration : urg_tcpclient.h:101</i>
     */
    int tcpclient_readline(urg_tcpclient_t cli, ByteBuffer userbuf, int buf_size, int timeout);

    /**
     * \brief Connection
     * <br>
     * Connects to the specified device
     * <br>
     * \param[in,out] connection Connection resource
     * <br>
     * \param[in] connection_type Connection type
     * <br>
     * \param[in] device Device name
     * <br>
     * \param[in] baudrate_or_port Baudrate or port number
     * <br>
     * \retval 0 Success
     * <br>
     * \retval <0 Error
     * <br>
     * The connection_type is either of:
     * <br>
     * - URG_SERIAL ... Serial connection
     * <br>
     * - URG_ETHERNET .. Ethernet connection
     * <br>
     * device and baudrate_or_port arguments are defined according to connection_type
     * <br>
     * For example, in case of serial connection:
     * <br>
     * Example
     * <br>
     * \code
     * <br>
     * connection_t connection;
     * <br>
     * if (! connection_open(&connection, URG_SERIAL, "COM1", 115200)) {
     * <br>
     * return 1;
     * <br>
     * } \endcode
     * <br>
     * And, in case of ethernet connection:
     * <br>
     * Example
     * <br>
     * \code
     * <br>
     * connection_t connection;
     * <br>
     * if (! connection_open(&connection, URG_ETHERNET, "192.168.0.10", 10940)) {
     * <br>
     * return 1;
     * <br>
     * } \endcode
     * <br>
     * \see connection_close()<br>
     * Original signature : <code>int connection_open(urg_connection_t*, urg_connection_type_t, const char*, long)</code><br>
     * <i>native declaration : urg_connection.h:77</i>
     */
    int connection_open(urg_connection_t connection, int connection_type, String device, NativeLong baudrate_or_port);

    /**
     * \brief Disconnection
     * <br>
     * Closes the connection with the device
     * <br>
     * \param[in,out] connection Connection resource
     * <br>
     * \code
     * <br>
     * connection_close(&connection); \endcode
     * <br>
     * \see connection_open()<br>
     * Original signature : <code>void connection_close(urg_connection_t*)</code><br>
     * <i>native declaration : urg_connection.h:92</i>
     */
    void connection_close(urg_connection_t connection);

    /**
     * \brief Configures the baudrate<br>
     * Original signature : <code>int connection_set_baudrate(urg_connection_t*, long)</code><br>
     * <i>native declaration : urg_connection.h:98</i>
     */
    int connection_set_baudrate(urg_connection_t connection, NativeLong baudrate);

    /**
     * \brief Send
     * <br>
     * Writes data over the communication channel
     * <br>
     * \param[in,out] connection Connection resource
     * <br>
     * \param[in] data Data to send
     * <br>
     * \param[in] size Number of bytes to send
     * <br>
     * \retval >=0 Number of bytes sent
     * <br>
     * \retval <0 Error
     * <br>
     * Example
     * <br>
     * \code
     * <br>
     * n = connection_write(&connection, "QT\n", 3); \endcode
     * <br>
     * \see connection_read(), connection_readline()<br>
     * Original signature : <code>int connection_write(urg_connection_t*, const char*, int)</code><br>
     * <i>native declaration : urg_connection.h:118</i>
     */
    int connection_write(urg_connection_t connection, String data, int size);

    /**
     * \brief Receive
     * <br>
     * Reads data from the communication channel
     * <br>
     * \param[in,out] connection Connection resource
     * <br>
     * \param[in] data Buffer to store received data
     * <br>
     * \param[in] max_size Maximum size of the buffer
     * <br>
     * \param[in] timeout Timeout [msec]
     * <br>
     * \retval >=0 Number of bytes received
     * <br>
     * \retval <0 Error
     * <br>
     * If timeout argument is negative then the function waits until some data is received
     * <br>
     * In case no data is received #URG_CONNECTION_TIMEOUT is returned.
     * <br>
     * Example
     * <br>
     * \code
     * <br>
     * enum {
     * <br>
     * BUFFER_SIZE = 256,
     * <br>
     * TIMEOUT_MSEC = 1000,
     * <br>
     * };
     * <br>
     * char buffer[BUFFER_SIZE];
     * <br>
     * n = connection_read(&connection, buffer, BUFFER_SIZE, TIMEOUT_MSEC); \endcode
     * <br>
     * \see connection_write(), connection_readline()<br>
     * Original signature : <code>int connection_read(urg_connection_t*, char*, int, int)</code><br>
     * <i>native declaration : urg_connection.h:149</i>
     */
    int connection_read(urg_connection_t connection, ByteBuffer data, int max_size, int timeout);

    /**
     * \brief Receive until end-of-line
     * <br>
     * Reads data until the end-of-line character is detected.
     * <br>
     * \param[in,out] connection Connection resource
     * <br>
     * \param[in] data Buffer to store received data
     * <br>
     * \param[in] max_size Maximum size of the buffer
     * <br>
     * \param[in] timeout Timeout [msec]
     * <br>
     * \retval >=0 Number of bytes received
     * <br>
     * \retval <0 Error
     * <br>
     * If timeout argument is negative then the function waits until some data is received
     * <br>
     * The null terminator character '\\0' is used at the end of data so that the number of bytes does not exceed max_size.
     * <br>
     * This is, the maximum number of received characters is max_size - 1.
     * <br>
     * The end-of-line character is either '\\r' or '\\n'
     * <br>
     * In case no end-of-line is received then returns 0, if no data is received #URG_CONNECTION_TIMEOUT is returned.
     * <br>
     * \see connection_write(), connection_read()<br>
     * Original signature : <code>int connection_readline(urg_connection_t*, char*, int, int)</code><br>
     * <i>native declaration : urg_connection.h:176</i>
     */
    int connection_readline(urg_connection_t connection, ByteBuffer data, int max_size, int timeout);

    /**
     * Original signature : <code>int urg_open(urg_t*, urg_connection_type_t, const char*, long)</code><br>
     * <i>native declaration : urg_sensor.h:121</i>
     */
    int urg_open(urg_t urg, int connection_type, String device_or_address, NativeLong baudrate_or_port);

    /**
     * Original signature : <code>void urg_close(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:134</i>
     */
    void urg_close(urg_t urg);

    /**
     * Original signature : <code>void urg_set_timeout_msec(urg_t*, int)</code><br>
     * <i>native declaration : urg_sensor.h:145</i>
     */
    void urg_set_timeout_msec(urg_t urg, int msec);

    /**
     * Original signature : <code>int urg_start_time_stamp_mode(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:151</i>
     */
    int urg_start_time_stamp_mode(urg_t urg);

    /**
     * Original signature : <code>long urg_time_stamp(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:177</i>
     */
    NativeLong urg_time_stamp(urg_t urg);

    /**
     * Original signature : <code>int urg_stop_time_stamp_mode(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:183</i>
     */
    int urg_stop_time_stamp_mode(urg_t urg);

    /**
     * Original signature : <code>int urg_start_measurement(urg_t*, urg_measurement_type_t, int, int)</code><br>
     * <i>native declaration : urg_sensor.h:230</i>
     */
    int urg_start_measurement(urg_t urg, int type, int scan_times, int skip_scan);

    /**
     * Original signature : <code>int urg_get_distance(urg_t*, long[], long*)</code><br>
     * <i>native declaration : urg_sensor.h:269</i>
     */
    int urg_get_distance(urg_t urg, long[] data, NativeLongByReference time_stamp);

    /**
     * Original signature : <code>int urg_get_distance_intensity(urg_t*, long[], unsigned short[], long*)</code><br>
     * <i>native declaration : urg_sensor.h:304</i>
     */
    int urg_get_distance_intensity(urg_t urg, long[] data, ShortBuffer intensity, NativeLongByReference time_stamp);

    /**
     * Original signature : <code>int urg_get_multiecho(urg_t*, long[], long*)</code><br>
     * <i>native declaration : urg_sensor.h:352</i>
     */
    int urg_get_multiecho(urg_t urg, long[] data_multi, NativeLongByReference time_stamp);

    /**
     * Original signature : <code>int urg_get_multiecho_intensity(urg_t*, long[], unsigned short[], long*)</code><br>
     * <i>native declaration : urg_sensor.h:385</i>
     */
    int urg_get_multiecho_intensity(urg_t urg, long[] data_multi, ShortBuffer intensity_multi, NativeLongByReference time_stamp);

    /**
     * Original signature : <code>int urg_stop_measurement(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:410</i>
     */
    int urg_stop_measurement(urg_t urg);

    /**
     * Original signature : <code>int urg_set_scanning_parameter(urg_t*, int, int, int)</code><br>
     * <i>native declaration : urg_sensor.h:426</i>
     */
    int urg_set_scanning_parameter(urg_t urg, int first_step, int last_step, int skip_step);

    /**
     * Original signature : <code>int urg_set_communication_data_size(urg_t*, urg_range_data_byte_t)</code><br>
     * <i>native declaration : urg_sensor.h:449</i>
     */
    int urg_set_communication_data_size(urg_t urg, int data_byte);

    /**
     * Original signature : <code>int urg_laser_on(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:456</i>
     */
    int urg_laser_on(urg_t urg);

    /**
     * Original signature : <code>int urg_laser_off(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:462</i>
     */
    int urg_laser_off(urg_t urg);

    /**
     * Original signature : <code>int urg_reboot(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:468</i>
     */
    int urg_reboot(urg_t urg);

    /**
     * Original signature : <code>void urg_sleep(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:483</i>
     */
    void urg_sleep(urg_t urg);

    /**
     * Original signature : <code>void urg_wakeup(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:490</i>
     */
    void urg_wakeup(urg_t urg);

    /**
     * Original signature : <code>int urg_is_stable(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:501</i>
     */
    int urg_is_stable(urg_t urg);

    /**
     * Original signature : <code>char* urg_sensor_product_type(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:512</i>
     */
    Pointer urg_sensor_product_type(urg_t urg);

    /**
     * Original signature : <code>char* urg_sensor_serial_id(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:523</i>
     */
    Pointer urg_sensor_serial_id(urg_t urg);

    /**
     * Original signature : <code>char* urg_sensor_firmware_version(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:534</i>
     */
    Pointer urg_sensor_firmware_version(urg_t urg);

    /**
     * Original signature : <code>char* urg_sensor_status(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:545</i>
     */
    Pointer urg_sensor_status(urg_t urg);

    /**
     * Original signature : <code>char* urg_sensor_state(urg_t*)</code><br>
     * <i>native declaration : urg_sensor.h:558</i>
     */
    Pointer urg_sensor_state(urg_t urg);

    /**
     * Original signature : <code>void urg_set_error_handler(urg_t*, urg_error_handler)</code><br>
     * <i>native declaration : urg_sensor.h:566</i>
     */
    void urg_set_error_handler(urg_t urg, UrgLib.urg_error_handler handler);


    /*!
      \brief Returns the string message for the last URG error

      \param[in] urg URG control structure

      \retval String message for the last URG error

      Example
      \code
      if (!urg_open(&urg, "/dev/ttyACM0", 115200, URG_SERIAL)) {
      printf("urg_open: %s\n", urg_error(&urg));
      return -1;
      } \endcode
    */
    String urg_error(urg_t urg);

    /*!
        \brief Obtains the minimum and maximum distance values from sensor measurements

        \param[in] urg URG control structure
        \param[out] min_distance minimum distance [mm]
        \param[out] max_distance maximum distance [mm]

        Example
        \code
        long min_distance, max_distance;
        urg_distance_min_max(&urg, &min_distance, &max_distance);

        for (int i = 0; i < n; ++i) {
        long distance = data[i];
        if ((distance < min_distance) || (distance > max_distance)) {
        continue;
        }
        ...
        } \endcode
      */
    void urg_distance_min_max(urg_t urg,
                              NativeLongByReference min_distance, NativeLongByReference max_distance);


    /*!
      \brief Gets the minimum and maximum step numbers

      Returns the minimum step and maximum step values as configured using urg_set_scanning_parameter()

      \param[in] urg URG control structure
      \param[out] min_step minimum step
      \param[out] max_step maximum step

      As seen from the top of the sensor: the frontal step is 0, going counter-clockwise are positive values, going clockwise are negative values.

      \image html sensor_step_image.png shows the relation between sensor and steps

      The actual values for min_step, max_step change with sensor type/series.

      Example
      \code
      urg_step_min_max(&urg, &min_step, &max_step);

      printf("range first: %d [deg]\n", urg_step2deg(&urg, min_step));
      printf("range last : %d [deg]\n", urg_step2deg(&urg, max_step)); \endcode

      \see urg_set_scanning_parameter(), urg_step2rad(), urg_step2deg()
    */
    void urg_step_min_max(urg_t urg, IntByReference min_step, IntByReference max_step);


    /*!
       \brief Returns the time [usec] for 1 scan
    */
    long urg_scan_usec(urg_t urg);


    /*!
       \brief Returns the maximum size of data received from the sensor
    */
    int urg_max_data_size(urg_t urg);


    /*!
      \brief Converts index to angle in radians

      Index is the position of each measurement data in the array returned using urg_get_distance().
      This function applies to the last array of measurement data read from the sensor.

      \param[in] urg URG control structure
      \param[in] index index value

      \return Angle [radian]

      The index value depends on the start/end steps configuration used for measurement.

      \image html sensor_index_image.png shows the relation between start/end step configuration and index

      Example
      \code
      int n = urg_get_distance(&urg, data, NULL);
      for (int i = 0; i < n; ++i) {
      long distance = data[i];
      double radian = urg_index2rad(i);
      double x = distance * cos(radian);
      double y = distance * sin(radian);
      printf("%.1f, %.1f\n", x, y);
      } \endcode

      \see urg_index2deg(), urg_rad2index(), urg_deg2index()
    */
    double urg_index2rad(urg_t urg, int index);


    /*!
       \brief Converts index to angle in degrees
    */
    double urg_index2deg(urg_t urg, int index);


    /*!
       \brief Converts angle in radians to index
    */
    int urg_rad2index(urg_t urg, double radian);


    /*!
       \brief Converts angle in degrees to index
    */
    int urg_deg2index(urg_t urg, double degree);

    /*!
      \brief Converts angle in radians to step number

      Conversion to angle (radian) is performed according to the min/max step definition using urg_step_min_max().

      \param[in] urg URG control structure
      \param[in] radian angle [radian]

      \return step value

      \image html sensor_angle_image.png shows the relation between steps and angles

      When the conversion from angle to step results on a fractional number, the value is rounded down towards zero (floor).

      \see urg_step_min_max(), urg_deg2step(), urg_step2rad(), urg_step2deg()
    */
    int urg_rad2step(urg_t urg, double radian);


    /*!
       \brief Converts angle in degrees to step number
    */
    int urg_deg2step(urg_t urg, double degree);


    /*!
       \brief Converts step number to angle in radians
    */
    double urg_step2rad(urg_t urg, int step);


    /*!
       \brief Converts step number to angle in degrees
    */
    double urg_step2deg(urg_t urg, int step);

    /*!
       \brief Converts step number to index
    */
    int urg_step2index(urg_t urg, int step);

    /**
     * Original signature : <code>long urg_scip_decode(const char[], int)</code><br>
     * <i>native declaration : urg_sensor.h:577</i>
     */
    NativeLong urg_scip_decode(byte data[], int size);

    public static class HANDLE extends PointerType {
        public HANDLE(Pointer address) {
            super(address);
        }

        public HANDLE() {
            super();
        }
    }

    public static class sockaddr_in extends PointerType {
        public sockaddr_in(Pointer address) {
            super(address);
        }

        public sockaddr_in() {
            super();
        }
    }
}
